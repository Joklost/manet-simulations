\chapter{Introduction}
\bibtodo{minor changes}
A \gls{manet} is a decentralised wireless network that requires no pre-existing infrastructure, such as
routers or access points~\cite{inproceedings:routingsurvery}. Instead, each node in the ad-hoc network are
battery powered, and communicates directly with each-other using a radio. Due to this, \gls{manet}s rely on
wireless networking protocols to provide energy efficient communication in the network. Because of the ad-hoc
nature of \gls{manet}s, common applications consist of enabling communication in emergency situations such as
natural disasters, or for military conflicts.\smallbreak

% Outline the goal
The goal of this project is to simulate wireless network protocols for communication in a mobile setting.
Ideally the capabilities of a wireless network protocol are tested in a real-life scenario, using physical
devices for radio communication. This poses interesting challenges such as scalability, and repeatability.
Scaling a real-life test requires a significant amount of effort and investment of both money and time, and
repeating the same test over and over becomes near impossible, the larger the scale. Our goal is to be able to
perform repeatable experiments in a control topology environment with up to 1000 devices, faster than a
real-life scenario.\smallbreak

Our project proposes a \gls{mpi} C++ library for writing, and running, simulations of the network protocol
behind the mesh communication in a \gls{manet}, modelling link \gls{pathloss} to simulate packet loss and
collisions caused by interfering transmitters, where the physical devices, and the communication between
these, are emulated entirely using software. With our library, it is be possible to write a C++ implementation
of communication protocols, such as \gls{lmac}~\cite{paper:lmac_protocol} or Slotted
ALOHA~\cite{Roberts:1975:APS:1024916.1024920}, using a simple interface header file resembling a traditional
hardware interface, and perform simulations with these, where each physical device is emulated in real-time by
different CPUs on the MCC compute cluster at AAU~\cite{website:mccaau}. \smallbreak

% Outline contributions
The primary contribution of this project is the Coordinator that facilitate wireless communication
between the emulated physical devices. The Coordinator allow us to simulate wireless communication
in virtual time, where the controller is able to skip periods of inactivity, reducing the time required to run
real-time simulations.

\todo[inline]{new contributions: building pathloss model, extension to visualiser}

\clearpage
\todo[inline]{place visualiser and add arrows from logs; add legend}
\begin{figure}[H]
    %\caption{Processing an \textit{inform} action.}\label{tikz:coordinatormsc3}
    % Diagram

    \begin{tikzpicture}[node distance=.8cm,start chain=going below,]
        \node[punktchain,rounded corners] (fieldmeasurements) {Field Measurements};

        \begin{scope}[start branch=venstre,every join/.style={->, thick, shorten <=1pt}, ]
            \node[punktchain, on chain=going left,rounded corners] (generateddata) {Random Walk Generated Topologies};
        \end{scope}

        \node[punktchain] (linkmodel) {Link Model\\ \autoref{sec:linkmodel}};

        \begin{scope}[start branch=venstre,every join/.style={->, thick, shorten <=1pt}, ]
            \node[punktchain,rounded corners, on chain=going left, join=by {<-}] (gpslogs) {GPS Logs};
            \node[punktchain,rounded corners, on chain=going below] (hardware) {Radio Hardware\\Parameters};
            \node[punktchain, on chain=going below, opacity=0] (hidden-left1) {};
            \node[punktchain,rounded corners, on chain=going below] (communication-log) {Communication Logs};
            \node[punktchain, on chain=going below, opacity=0] (hidden-left2) {};

            \node[punktchain,on chain=going below] (visualiser) {Visualiser\\ \autoref{sec:visualiser}};

            %\node[punktchain, on chain=going below, opacity=0] (hidden-left3) {};
            \node[punktchain, on chain=going below, opacity=0] (hidden-left4) {};
            \node[punktchain, minimum height=6em, on chain=going below, opacity=0] (hidden-left5) {};
            \node[punktchain,rounded corners, on chain=going below] (protocol-log) {Protocol Log};
        \end{scope}

        \begin{scope}[start branch=hoejre,]
            \node[punktchain,rounded corners, on chain=going right, join=by {->}] (gpslogs-rssi) {GPS Logs + RSSI};
            %\node[punktchain, on chain=going below, join] (radiomodel) {Radio Simulator\\ \autoref{sec:pep}};
        \end{scope}

        \node[punktchain] (radiomodel) {Radio Simulator\\ \autoref{sec:pep}};
        \node[punktchain, opacity=0] (hidden1) {};
        \node[punktchain] (coordinator) {Coordinator\\ \autoref{sec:coordinator}};
        \node[punktchain, opacity=0] (hidden2) {};
        \node[punktchain] (radio-middleware) {Radio Middleware\\ \autoref{sec:interface}};
        \node[punktchain, opacity=0] (hidden3) {};
        \node[punktchain, minimum height=6em, minimum width=20em] (executable-code) {Executable Code\\ \ \\ \ \\ \ \\};
        \node[below left=-0.3cm and 2.05cm of executable-code.center, rectangle, draw=black, very thick, minimum height=3em, minimum width=3em] (node1) {\Node{1}};
        \node[below left=-0.3cm and 0cm of executable-code.center, rectangle, draw=black, very thick, minimum height=3em, minimum width=3em] (node2) {\Node{2}};
        \node[below right=-0.3cm and 2.05cm of executable-code.center, rectangle, draw=black, very thick, minimum height=3em, minimum width=3em] (noden) {\Node{$n$}};
        \node[between=node2 and noden] (nodedots) {\dots};
        %\node[punktchain, opacity=0] (hidden4) {};
        \node[punktchain] (protocol-code) {C++ Protocol Impl.\\ \autoref{sec:lmacc}};
        %\node[punktchain] (visualiser) {Visualiser\\ \autoref{sec:visualiser}};

        \draw[|-,-|,<-, thick,] (linkmodel.south) |-+(0,-1em)-| (hardware.north);
        \draw[|-,-|,->, thick,] (hardware.east) to (radiomodel.west);
        \draw[|-,-|,->, thick,] (generateddata.south) |-+(0,-1em)-| (gpslogs.north);
        \draw[|-,-|,->, thick,] (fieldmeasurements.south) |-+(0,-1em)-| (gpslogs.north);
        \draw[|-,-|,->, thick,] (fieldmeasurements.south) |-+(0,-1em)-| (gpslogs-rssi.north);

        \draw[|-,-|,->, thick, transform canvas={xshift=-1.3cm}] (radiomodel.south) to (coordinator.north) node[align=right,above left=0.8cm and 0.5cm] {Probability for\\packet error $p$};
        \draw[|-,-|,<-, thick, transform canvas={xshift=1.3cm}] (radiomodel.south) to (coordinator.north) node[align=left,above right=0.9cm and 0.5cm] {$P_p(n_r, m_t, \mathit{nodes}_i, \mathit{packetsize}, t)$};

        \draw[|-,-|,->, thick, transform canvas={xshift=-1.3cm}] (coordinator.south) to (radio-middleware.north) node[align=right,above left=0.8cm and 0.5cm] {Received \\ packets};
        \draw[|-,-|,<-, thick, transform canvas={xshift=1.3cm}] (coordinator.south) to (radio-middleware.north) node[align=left,above right=0.4cm and 0.5cm] {Transmit\\Listen\\Sleep\\Inform};


        \draw[|-,-|,->, thick, transform canvas={xshift=-1.3cm}] (radio-middleware.south) to (executable-code.north) node[align=right,above left=0.8cm and 0.5cm] {Received \\ packets};
        \draw[|-,-|,<-, thick, transform canvas={xshift=1.3cm}] (radio-middleware.south) to (executable-code.north) node[align=left,above right=0.4cm and 0.5cm] {Broadcast\\Receive\\Sleep\\Inform};

        \draw[|-,-|,->, thick,] (protocol-code) to (executable-code);
        \draw[|-,-|,->, thick,] (coordinator) to (communication-log);
        \draw[|-,-|,->, thick,] (protocol-code) to (protocol-log);

        %\draw[|-,-|,->, thick,] (radiomodel.south) |-+(0,-1em)-| (coordinator.north);

        %\begin{scope}[start branch=venstre,
        %    %We need to redefine the join-style to have the -> turn out right
        %    every join/.style={->, thick, shorten <=1pt}, ]
        %    \node[punktchain, on chain=going left, join=by {<-}]
        %        (risiko) {Risiko og gamble};
        %  \end{scope}

        %\node[punktchain, join] (intro) {Introduktion};
        %\node[punktchain, join] (probf)      {Problemformulering};
        %\node[punktchain, join] (investeringer)      {Investeringsteori};
        %\node[punktchain, join] (perfekt) {Det perfekte kapitalmarked};
        %\node[punktchain, join, ] (emperi) {Emperi};
        %\node (asym) [punktchain ]  {Asymmetrisk information};
        %\begin{scope}[start branch=venstre,
        %        %We need to redefine the join-style to have the -> turn out right
        %        every join/.style={->, thick, shorten <=1pt}, ]
        %    \node[punktchain, on chain=going left, join=by {<-}]
        %    (risiko) {Risiko og gamble};
        %\end{scope}
        %\begin{scope}[start branch=hoejre,]
        %    \node (finans) [punktchain, on chain=going right] {Det finansielle system};
        %\end{scope}
        %\node[punktchain, join,] (disk) {Det imperfekte finansielle marked};
        %\node[punktchain, join,] (makro) {InvesteringsmÃ¦ssige konsekvenser};
        %\node[punktchain, join] (konk) {Konklusion};
        % Now that we have finished the main figure let us add some "after-drawings"
        %% First, let us connect (finans) with (disk). We want it to have
        %% square corners.
        %\draw[|-,-|,->, thick,] (finans.south) |-+(0,-1em)-| (disk.north);
        % Now, let us add some braches. 
        %% No. 1
        %\draw[tuborg] let
        %\p1=(risiko.west), \p2=(finans.east) in
        %($(\x1,\y1+2.5em)$) -- ($(\x2,\y2+2.5em)$) node[above, midway]  {Teori};
        %% No. 2
        %\draw[tuborg, decoration={brace}] let \p1=(disk.north), \p2=(makro.south) in
        %($(2, \y1)$) -- ($(2, \y2)$) node[tubnode] {Analyse};
        %% No. 3
        %\draw[tuborg, decoration={brace}] let \p1=(perfekt.north), \p2=(emperi.south) in
        %($(2, \y1)$) -- ($(2, \y2)$) node[tubnode] {Problemfelt};
    \end{tikzpicture}

\end{figure}

\clearpage