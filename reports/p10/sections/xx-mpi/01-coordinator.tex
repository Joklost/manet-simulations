
\paragraph{Hardware Functions}\label{sec:hwfuncspseudo}
The hardware functions listed in this section depend on the following local state. The local state is unique for each node.\smallbreak

clock $\leftarrow$ \KwNow

localtime $\leftarrow$ 0

id $\leftarrow$ unique identifier \smallbreak

In the hardware functions we utilise a special keyword \singlequote{\KwNow}, which represents the real-time hardware clocks of a node. It is assumed that all nodes start at the same time. Initially, we store the current time in the clock variable, and use this variable to compute the real-time difference between the calling of hardware functions. At the end of each of the four functions we reset the clock variable to \singlequote{\KwNow}, after the localtime of node has been updated.\medbreak

\begin{algorithm}[H]
    \DontPrintSemicolon
    \SetKwFunction{FBroadcast}{Broadcast}
    \SetKwProg{Fn}{Function}{}{}
    
    \Fn{\FBroadcast{packet}}{
        localtime $\leftarrow$ (\KwNow $-$ clock) $+$ localtime\;
        duration $\leftarrow$ transmission\_time(|packet|)\;
        endtime $\leftarrow$ localtime $+$ duration\;
        a $\leftarrow$ (transmit, id, localtime, endtime, packet)\;
        \KwSend a \KwTo coordinator\;
        localtime $\leftarrow$ endtime\;
        clock $\leftarrow$ \KwNow\;
    }

    \caption{The \texttt{Broadcast} Function.}
    \label{algo:hwfuncstransmit}
\end{algorithm}

\begin{algorithm}[H]
    \DontPrintSemicolon
    \KwResult{A packet or \KwNull}
    \SetKwFunction{FListen}{Listen}
    \SetKwProg{Fn}{Function}{}{}
    
    \Fn{\FListen{duration}}{
        localtime $\leftarrow$ (\KwNow $-$ clock) $+$ localtime\;
        a $\leftarrow$ (listen, id, localtime, localtime $+$ duration, \KwNull)\;
        \KwSend a \KwTo coordinator\;
        localtime $\leftarrow$ \KwAwait endtime \KwFrom coordinator\;
        packet $\leftarrow$ \KwAwait packet \KwFrom coordinator\;
        clock $\leftarrow$ \KwNow\;
        \KwRet packet\;
    }
    
    \caption{The \texttt{Listen} Function.}
    \label{algo:hwfuncslisten}
\end{algorithm}

\begin{algorithm}[H]
    \DontPrintSemicolon
    \SetKwFunction{FSleep}{Sleep}
    \SetKwProg{Fn}{Function}{}{}
    
    \Fn{\FSleep{duration}}{
        localtime $\leftarrow$ (\KwNow $-$ clock) $+$ localtime\;
        endtime $\leftarrow$ localtime $+$ duration\;
        a $\leftarrow$ (sleep, id, localtime, endtime, \KwNull)\;
        \KwSend a \KwTo coordinator\;
        localtime $\leftarrow$ endtime\;
        clock $\leftarrow$ \KwNow\;
    }
    
    \caption{The \texttt{Sleep} Function.}
    \label{algo:hwfuncssleep}
\end{algorithm}

\begin{algorithm}[H]
    \DontPrintSemicolon
    \SetKwFunction{FInformLocalTime}{InformLocalTime}
    \SetKwProg{Fn}{Function}{}{}
    
    \Fn{\FInformLocalTime{}}{
        localtime $\leftarrow$ (\KwNow $-$ clock) $+$ localtime\;
        a $\leftarrow$ (inform, id, localtime, localtime, \KwNull)\;
        \KwSend a \KwTo coordinator\;
        clock $\leftarrow$ \KwNow\;
    }
    
    \caption{The \texttt{InformLocaltime} Function.}
    \label{algo:hwfuncsupdatelocaltime}
\end{algorithm}

\pagebreak

\paragraph{Coordinator} running in parallel along nodes.\smallbreak

\begin{algorithm}[H]
    \DontPrintSemicolon
    \SetKwFunction{FCoordinator}{Coordinator}
    \SetKwProg{Fn}{procedure}{}{}

    Action = (type, source, start, end, packet)\;
    \;

    \Fn{\FCoordinator{}}{
        waiting $\leftarrow$ priority queue of Action objects, ordered by end, transmit before listen\;
        transmissions $\leftarrow$ empty list of Action objects\;
        \;
        
        \Repeat{\textit{protocol terminates}}{
            \tcp{Part 1. Handle incoming messages.}
            a $\leftarrow$ \KwAwait Action \KwFrom any node\; \label{line:action-await}
            \KwEnqueue a \KwTo waiting\;
            \If{a.type = transmit}{ \label{line:message-transmit}
                \KwAppend a \KwTo transmissions\;
            }
            
            \;
            \tcp{Part 2. Process waiting actions.}
            \While{each node has at least one Action in waiting}{
                a $\leftarrow$ \KwDequeue Action \KwFrom waiting\;

                \If{a.type = transmit}{ \label{line:action-transmit}
                    interferers $\leftarrow$ empty list of node identifiers\;
                    \ForEach{t $\in$ transmissions \KwWhere t $\neq$ a}{
                        \If{a.end $\geq$ t.start \KwAnd a.start $\leq$ t.end}{
                            \tcp{Transmissions intersect}
                            \KwAppend t.source \KwTo interferers\;
                        }
                    }

                    \ForEach{l $\in$ waiting \KwWhere l.type = listen}{
                        \If{a.start $\geq$ l.start \KwAnd a.end $\leq$ l.end}{
                            probability $\leftarrow$ $P_p$(l.source, a.source, interferers, |a.packet|)\;
                            should-receive $\leftarrow$ randomly choose based on probability\;
                            \If{should-receive}{
                                l.end = a.end\;
                                l.packet = a.packet\;
                            }
                        }
                    }
                }

                \ElseIf{a.type = listen}{ \label{line:action-listen}
                    \KwSend a.end \KwTo a.source\;
                    \KwSend a.packet \KwTo a.source\;
                }
                \tcp{Sleep/Inform actions are handled implicitly.}
            }
            \;
            \tcp{Part 3. Clean transmissions list.}            
            start-time $\leftarrow$ earliest start time of all actions \KwInn waiting\;
            \ForEach{t $\in$ transmissions \KwWhere t.end < start-time}{
                \KwRemove t \KwFrom transmissions\;
            }
        }
    }
    \caption{The \texttt{Coordinator} procedure.}
    \label{algo:mpicoordinator}
\end{algorithm}

\pagebreak

% \paragraph{Invariants} for procedure.\smallbreak

% For all nodes, we know at all times what the node is doing at that time. At any given time moment, we need to be able to reconstruct a situation from our data structures, such that we can show who is doing what at each time. This is the current configuration at a given time.

% \begin{itemize}
%     \item At any time, the waiting queue will contain a maximum of one listen action from each node.
%     \item For each node:
%     \begin{itemize}
%         \item 
%     \end{itemize}
% % \end{itemize}

% Assumptions

% \begin{itemize}
%     \item We know at all times what any node is doing.
%     \item Any transmission for a given time interval will be processed before a listen action with the same interval or a greater one (where the transmission interval is wholly within the listen interval).
%     \item At any time, the waiting queue will contain a maximum of one listen action from each node.
%     \item A transmission t will always be present in the waiting queue prior to handling a listen action l, and if the intervals of t and l intersect, we will only handle t when l is still on the queue.
% \end{itemize}


% Diagram
\begin{tikzpicture}[every node/.style={font=\normalsize,minimum height=0.5cm,minimum width=0.5cm},]

% Matrix
\node [matrix, very thin,column sep=1cm,row sep=0.5cm] (matrix) at (0,0) {
                          & \node(0,0) (\Node{1} 00) {}; && \node(0,0) (\Node{2} 00) {}; && \node(0,0) (\Node{3} 00) {}; && \node(0,0) (\Node{4} 00) {}; && \node(0,0) (\Node{5} 00) {}; &                            \\
\node(0,0) (t01 left) {}; & \node(0,0) (\Node{1} 01) {}; && \node(0,0) (\Node{2} 01) {}; && \node(0,0) (\Node{3} 01) {}; && \node(0,0) (\Node{4} 01) {}; && \node(0,0) (\Node{5} 01) {}; & \node(0,0) (t01 right) {}; \\
\node(0,0) (t02 left) {}; & \node(0,0) (\Node{1} 02) {}; && \node(0,0) (\Node{2} 02) {}; && \node(0,0) (\Node{3} 02) {}; && \node(0,0) (\Node{4} 02) {}; && \node(0,0) (\Node{5} 02) {}; & \node(0,0) (t02 right) {}; \\
\node(0,0) (t03 left) {}; & \node(0,0) (\Node{1} 03) {}; && \node(0,0) (\Node{2} 03) {}; && \node(0,0) (\Node{3} 03) {}; && \node(0,0) (\Node{4} 03) {}; && \node(0,0) (\Node{5} 03) {}; & \node(0,0) (t03 right) {}; \\
\node(0,0) (t04 left) {}; & \node(0,0) (\Node{1} 04) {}; && \node(0,0) (\Node{2} 04) {}; && \node(0,0) (\Node{3} 04) {}; && \node(0,0) (\Node{4} 04) {}; && \node(0,0) (\Node{5} 04) {}; & \node(0,0) (t04 right) {}; \\
\node(0,0) (t05 left) {}; & \node(0,0) (\Node{1} 05) {}; && \node(0,0) (\Node{2} 05) {}; && \node(0,0) (\Node{3} 05) {}; && \node(0,0) (\Node{4} 05) {}; && \node(0,0) (\Node{5} 05) {}; & \node(0,0) (t05 right) {}; \\
\node(0,0) (t06 left) {}; & \node(0,0) (\Node{1} 06) {}; && \node(0,0) (\Node{2} 06) {}; && \node(0,0) (\Node{3} 06) {}; && \node(0,0) (\Node{4} 06) {}; && \node(0,0) (\Node{5} 06) {}; & \node(0,0) (t06 right) {}; \\
\node(0,0) (t07 left) {}; & \node(0,0) (\Node{1} 07) {}; && \node(0,0) (\Node{2} 07) {}; && \node(0,0) (\Node{3} 07) {}; && \node(0,0) (\Node{4} 07) {}; && \node(0,0) (\Node{5} 07) {}; & \node(0,0) (t07 right) {}; \\
\node(0,0) (t08 left) {}; & \node(0,0) (\Node{1} 08) {}; && \node(0,0) (\Node{2} 08) {}; && \node(0,0) (\Node{3} 08) {}; && \node(0,0) (\Node{4} 08) {}; && \node(0,0) (\Node{5} 08) {}; & \node(0,0) (t08 right) {}; \\
\node(0,0) (t09 left) {}; & \node(0,0) (\Node{1} 09) {}; && \node(0,0) (\Node{2} 09) {}; && \node(0,0) (\Node{3} 09) {}; && \node(0,0) (\Node{4} 09) {}; && \node(0,0) (\Node{5} 09) {}; & \node(0,0) (t09 right) {}; \\
\node(0,0) (t10 left) {}; & \node(0,0) (\Node{1} 10) {}; && \node(0,0) (\Node{2} 10) {}; && \node(0,0) (\Node{3} 10) {}; && \node(0,0) (\Node{4} 10) {}; && \node(0,0) (\Node{5} 10) {}; & \node(0,0) (t10 right) {}; \\
\node(0,0) (t11 left) {}; & \node(0,0) (\Node{1} 11) {}; && \node(0,0) (\Node{2} 11) {}; && \node(0,0) (\Node{3} 11) {}; && \node(0,0) (\Node{4} 11) {}; && \node(0,0) (\Node{5} 11) {}; & \node(0,0) (t11 right) {}; \\
\node(0,0) (t12 left) {}; & \node(0,0) (\Node{1} 12) {}; && \node(0,0) (\Node{2} 12) {}; && \node(0,0) (\Node{3} 12) {}; && \node(0,0) (\Node{4} 12) {}; && \node(0,0) (\Node{5} 12) {}; & \node(0,0) (t12 right) {}; \\
\node(0,0) (t13 left) {}; & \node(0,0) (\Node{1} 13) {}; && \node(0,0) (\Node{2} 13) {}; && \node(0,0) (\Node{3} 13) {}; && \node(0,0) (\Node{4} 13) {}; && \node(0,0) (\Node{5} 13) {}; & \node(0,0) (t13 right) {}; \\
\node(0,0) (t14 left) {}; & \node(0,0) (\Node{1} 14) {}; && \node(0,0) (\Node{2} 14) {}; && \node(0,0) (\Node{3} 14) {}; && \node(0,0) (\Node{4} 14) {}; && \node(0,0) (\Node{5} 14) {}; & \node(0,0) (t14 right) {}; \\
\node(0,0) (t15 left) {}; & \node(0,0) (\Node{1} 15) {}; && \node(0,0) (\Node{2} 15) {}; && \node(0,0) (\Node{3} 15) {}; && \node(0,0) (\Node{4} 15) {}; && \node(0,0) (\Node{5} 15) {}; & \node(0,0) (t15 right) {}; \\
\node(0,0) (t16 left) {}; & \node(0,0) (\Node{1} 16) {}; && \node(0,0) (\Node{2} 16) {}; && \node(0,0) (\Node{3} 16) {}; && \node(0,0) (\Node{4} 16) {}; && \node(0,0) (\Node{5} 16) {}; & \node(0,0) (t16 right) {}; \\
\node(0,0) (t17 left) {}; & \node(0,0) (\Node{1} 17) {}; && \node(0,0) (\Node{2} 17) {}; && \node(0,0) (\Node{3} 17) {}; && \node(0,0) (\Node{4} 17) {}; && \node(0,0) (\Node{5} 17) {}; & \node(0,0) (t17 right) {}; \\
\node(0,0) (t18 left) {}; & \node(0,0) (\Node{1} 18) {}; && \node(0,0) (\Node{2} 18) {}; && \node(0,0) (\Node{3} 18) {}; && \node(0,0) (\Node{4} 18) {}; && \node(0,0) (\Node{5} 18) {}; & \node(0,0) (t18 right) {}; \\
\node(0,0) (t19 left) {}; & \node(0,0) (\Node{1} 19) {}; && \node(0,0) (\Node{2} 19) {}; && \node(0,0) (\Node{3} 19) {}; && \node(0,0) (\Node{4} 19) {}; && \node(0,0) (\Node{5} 19) {}; & \node(0,0) (t19 right) {}; \\
                          & \node(0,0) (\Node{1} en) {}; && \node(0,0) (\Node{2} en) {}; && \node(0,0) (\Node{3} en) {}; && \node(0,0) (\Node{4} en) {}; && \node(0,0) (\Node{5} en) {}; &                            \\%
};

% Agents labels
\fill 
	(\Node{1} 00) node[draw,fill=white] {\Node{1}}%
	(\Node{2} 00) node[draw,fill=white] {\Node{2}}%
	(\Node{3} 00) node[draw,fill=white] {\Node{3}}%
	(\Node{4} 00) node[draw,fill=white] {\Node{4}}%
    (\Node{5} 00) node[draw,fill=white] {\Node{5}}%
    ;

% Vertical lifelines
\draw [dashed] 
    (\Node{1} 00) -- (\Node{1} en)%
    (\Node{2} 00) -- (\Node{2} en)%
    (\Node{3} 00) -- (\Node{3} en)%
    (\Node{4} 00) -- (\Node{4} en)%
    (\Node{5} 00) -- (\Node{5} en)%
    ;


% Horizontal time lines
\draw [dotted] 
    (t05 left) -- (t05 right) node[right,text width=3cm] {waiting $\leftarrow$ \{ $t_4$,  $i_5$, $l_2$, \}}%
    ;

%\def\Node#1{Node #1}



% Node{1} {
    \Transmit{1}{02}{06}
    \Sleep{1}{06}{07}
    \Transmit{1}{07}{13}
%}

% Node{2} {
    \Listen{2}{02}{05}
    \Sleep{2}{05}{07}
    \Transmit{2}{08}{10}
%}

% Node{3} {
    \Listen{3}{01}{06}
%}

% Node{4} {
    \Transmit{4}{01}{03}
    \Sleep{4}{04}{08}
%}

% Node{5} {
    \Inform{5}{05}
    \Listen{5}{06}{09}
    \Transmit{5}{10}{12}
%}

\end{tikzpicture}