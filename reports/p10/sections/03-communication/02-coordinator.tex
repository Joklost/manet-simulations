\section{Coordinator}\label{sec:coordinator}
\todo[inline]{bibliographical remark: a lot of changes from Controller}
\todo[inline]{first 3 paragraphs, not logical order. refer back to hardware section \autoref{sec:hwfuncspseudo}}

To facilitate communication between nodes using the hardware interface, we introduce the Coordinator. The
Coordinator works by gathering actions (\textit{transmit}, \textit{listen}, \textit{sleep}, and
\textit{inform}) sent from nodes using an \gls{mpi}. The pseudo code description of the Coordinator can be
seen in \autoref{algo:mpicoordinator}. \smallbreak

The Coordinator works by continuously awaiting actions from any node
(\autoref{algo:mpicoordinator:action-await}). The \KwAwait keyword is blocking, and blocks until any node
sends an action to the Coordinator. An action is the 5-tuple Action = $(\mathit{type},\ \mathit{source},\
\mathit{start},\ \mathit{end},\ \mathit{packet})$. Accessing an element of an action is done with the dot
($.$) operator, using named access. For example, if node $1$ starts listening at time $2$ and ends listening
at time $5$, we have the \textit{listen} action $a = (\mathit{listen}, 1, 2, 5, \KwNull)$. We can access the
source of the action using the dot operator as such: $a.source = 1$. The $\mathit{type}$ element denotes the
type of the action, and is one of either \textit{transmit}, \textit{listen}, \textit{sleep}, or
\textit{inform}. The $\mathit{source}$ element is the unique identifier of the source node that submitted the
action to the Coordinator. The $\mathit{start}$ and $\mathit{end}$ elements are timestamps for points of time
in the execution, where $\mathit{start} \leq \mathit{end}$. Finally, the $\mathit{packet}$ element is the data
packet sent during a transmission, or \KwNull for any action where $\mathit{type} \neq \mathit{transmit}$.
\smallbreak

The pseudo code of the Coordinator is separated into three parts, where each of the parts is repeatedly
executed in sequence, until the protocol terminates. The first part takes care of receiving actions from
nodes, the second part maintains and cleans the $\mathit{transmits}$ set of \textit{transmit} actions, and the
third part processes, and removes, actions from the $\mathit{waiting}$ queue. \smallbreak

Whenever an action is submitted to the Coordinator (\autoref{algo:mpicoordinator:action-await}), the action is
enqueued in the $\mathit{waiting}$ queue, and added to the \textit{discovered} set. The $\mathit{waiting}$
queue is a priority queue of Action objects, where the actions are ordered by their end time, with
\textit{transmit} actions before \textit{listen} actions, in case of a tie. The \textit{discovered} set is
a set used to track all actions submitted to the Coordinator. The ordering of \textit{sleep} and
\textit{inform} in relation to \textit{transmit} or \textit{listen} actions in the \textit{waiting} queue are
irrelevant. If the received action is a \textit{transmit} action, the action is also added to the
$\mathit{transmits}$ set (\autoref{algo:mpicoordinator:message-transmit}). Note that any action we receive
from a particular node during this part will always have a start time greater than or equal to the end time of
the last action received from that node. After receiving an action, the Coordinator continues to the second
part. \smallbreak

The $\mathit{transmits}$ set is used to gather any \textit{transmit} actions that may cause interference when
processing \textit{transmit} actions in the third part of the Coordinator. In order to make sure that the size
of the $\mathit{transmits}$ set does not grow indefinitely, we remove \textit{transmit} actions that will not
interfere with future \textit{transmit} actions. To do this we check that the $\mathit{waiting}$ queue
contains at least one action from each node (\autoref{algo:mpicoordinator:ifactions}). Next, we find the
earliest start time of all actions in the $\mathit{waiting}$ queue. With this we can remove any
\textit{transmit} actions where the end time is strictly less that then earliest start time found in the
$\mathit{waiting}$ queue (\autoref{algo:mpicoordinator:cleantransmits}). \smallbreak

Finally, in the third part of the Coordinator, we process actions from the \textit{waiting} queue. The
Coordinator only processes actions when the \textit{waiting} queue fulfils the same condition as in the second
part, where the \textit{waiting} queue has to contain at least one action from each node. While this is the
case, the Coordinator dequeues a single action (\autoref{algo:mpicoordinator:dequeue}) from the
\textit{waiting} queue. Any \textit{sleep} or \textit{inform} actions are processed implicitly, as they only
have to be present in the \textit{waiting} queue, to satisfy the condition of the loop. Only the
\textit{transmit} and \textit{listen} actions need processing by the Coordinator. \par %\smallbreak 

\begin{algorithm}[H]
    \DontPrintSemicolon
    \SetKwFunction{FCoordinator}{Coordinator}
    \SetKwProg{Fn}{procedure}{}{}

    Action = $(\mathit{type},\ \mathit{source},\ \mathit{start},\ \mathit{end},\ \mathit{packet})$\; \label{algo:mpicoordinator:actiontuple}
    \;

    \Fn{\FCoordinator{}}{
        $\mathit{waiting}$ $\leftarrow$ priority queue of Action objects, ordered by $\mathit{end}$ time, \;
        \hspace{18.5mm}\textit{sleep} and \textit{inform} before \textit{transmit}, \textit{transmit} before \textit{listen}\;
        $\mathit{discovered} \leftarrow$ empty set of Action objects\; \label{algo:mpicoordinator:discovered}
        $\mathit{transmits}$ $\leftarrow$ empty set of Action objects\;
        \;

        \Repeat{\textit{protocol terminates}}{
            \tcp{Part 1. Handle incoming message.}
            $a$ $\leftarrow$ \KwAwait Action \KwFrom any node\; \label{algo:mpicoordinator:action-await}
            \KwAppend $a$ \KwTo $\mathit{discovered}$\;
            \If{$a$.$\mathit{type}$ = \textit{transmit}}{ \label{algo:mpicoordinator:message-transmit}
                \KwAppend $a$ \KwTo $\mathit{transmits}$\;
            }
            \KwEnqueue $a$ \KwTo $\mathit{waiting}$\;
            \;
            \tcp{Part 2. Clean $\mathit{transmits}$ set.}
            \If{each node has at least one Action \KwIn $\mathit{waiting}$}{ \label{algo:mpicoordinator:ifactions}
                $\mathit{starttime}$ $\leftarrow$ earliest $\mathit{start}$ time of all actions \KwInn $\mathit{waiting}$\;
                \ForEach{$t$ $\in$ $\mathit{transmits}$ \KwWhere $t$.$\mathit{end}$ < $\mathit{starttime}$}{ \label{algo:mpicoordinator:cleantransmits}
                    \KwRemove $t$ \KwFrom $\mathit{transmits}$\;
                }
            }
            \;
            \tcp{Part 3. Process $\mathit{waiting}$ actions.}
            \While{each node has at least one Action \KwIn $\mathit{waiting}$}{ \label{algo:mpicoordinator:whileactions}
                $a$ $\leftarrow$ \KwDequeue Action \KwFrom $\mathit{waiting}$\; \label{algo:mpicoordinator:dequeue}

                \If{$a$.$\mathit{type}$ = \textit{transmit}}{ \label{line:action-transmit}
                    $\mathit{interferers}$ $\leftarrow$ empty set of node identifiers\;
                    \ForEach{$t$ $\in$ $\mathit{transmits}$ \KwWhere $t$ $\neq$ $a$}{ \label{algo:mpicoordinator:foreachinterfere}
                        \If{$a$.$\mathit{end}$ $\geq$ $t$.$\mathit{start}$ \KwAnd $a$.$\mathit{start}$ $\leq$ $t$.$\mathit{end}$}{ \label{algo:mpicoordinator:transmitintersects}
                            \tcp{Transmissions intersect.}
                            \KwAppend $t$.$\mathit{source}$ \KwTo $\mathit{interferers}$\;
                        }
                    }

                    \ForEach{$l$ $\in$ $\mathit{waiting}$ \KwWhere $l$.$\mathit{type}$ = \textit{listen}}{
                        \If{$a$.$\mathit{start}$ $\geq$ $l$.$\mathit{start}$ \KwAnd $a$.$\mathit{end}$ $\leq$ $l$.$\mathit{end}$}{
                            $p$ $\leftarrow$ $P_p$($l$.$\mathit{source}$, $a$.$\mathit{source}$, $\mathit{interferers}$, |$a$.$\mathit{packet}$|, $a$.$\mathit{end}$)\; \label{mpi:coordinator:pep}
                            $shouldreceive$ $\leftarrow$ randomly choose based on $p$\;
                            \If{$shouldreceive$}{ \label{algo:mpicoordinator:shouldreceive}
                                \KwRemove $l$ \KwFrom $\mathit{waiting}$\; \label{algo:mpicoordinator:removelisten}
                                \KwSend $a$.$\mathit{end}$ \KwTo $l$.$\mathit{source}$\;
                                \KwSend $a$.$\mathit{packet}$ \KwTo $l$.$\mathit{source}$\;
                            }
                        }
                    }
                }

                \ElseIf{$a$.$\mathit{type}$ = \textit{listen}}{ \label{line:action-listen}
                    \KwSend $a$.$\mathit{end}$ \KwTo $a$.$\mathit{source}$\; \label{algo:mpicoordinator:unblock2}
                    \KwSend \KwNull \KwTo $a$.$\mathit{source}$\; \label{algo:mpicoordinator:sendnull}
                }
                \tcp{\textit{sleep}/\textit{inform} actions are handled implicitly.}
            }
        }
    }
    \caption{The \texttt{Coordinator} procedure.}
    \label{algo:mpicoordinator}
\end{algorithm}

When processing a \textit{transmit} action, the Coordinator first gathers all \textit{transmit} actions from
the \textit{transmits} set, that interfere with the \textit{transmit} action being processed
(\autoref{algo:mpicoordinator:foreachinterfere}). A \textit{transmit} actions causes interference with
another, if at any point in time their time intervals intersect
(\autoref{algo:mpicoordinator:transmitintersects}). All applicable \textit{transmit} actions are stored in the
\textit{interferers} set, to be used when computing the probability for packet error. Next, the Coordinator
iterates through all \textit{listen} actions in the \textit{waiting} queue, and if the time interval of the
\textit{transmit} action is fully within the time interval of the \textit{listen} action, the \textit{listen}
action is considered relevant for the \textit{transmit} action, and we compute the probability for the packet
being received by the listening node (\autoref{mpi:coordinator:pep}). The probability of the packet being
received is computed using the probability for packet error function $P_p$ (\autoref{eq:pep} in
\autoref{sec:radiomodel}). The probability for packet error function is called using the source of the
\textit{listen} action $l$, the source of the \textit{transmit} action $a$, the \textit{interferers} set, the
size of the packet, as well as the end time of the \textit{transmit} action $a$. Finally, we randomly chose
whether the packet should be received by using the computed probability $p$
(\autoref{algo:mpicoordinator:shouldreceive}). If the listening node has been chosen to receive the packet,
the \textit{listen} action $l$ is removed from the \textit{waiting} queue
(\autoref{algo:mpicoordinator:removelisten}), and the end time of the \textit{transmit} action $a$, as well as
the packet is sent to the source of the \textit{listen} node. \smallbreak

Processing a \textit{listen} action (\autoref{algo:mpicoordinator:unblock2}) is trivial, as all the
Coordinator does is send the end time of the \textit{listen} action and \KwNull to the source of the
\textit{listen} action. We do this as dequeuing a \textit{listen} action means that no transmission has been
received by the listening node. When the Coordinator responds to the source of the \textit{listen} action,
the node is unblocked, and may continue executing its protocol.

\subsection{Hardware}\label{sec:hwfuncspseudo}
\bibtodo{changed according to new functionality}
The hardware functions listed in this section depend on the following local state. The local state is unique
for each node.\smallbreak

clock $\leftarrow$ \KwNow

localtime $\leftarrow$ 0

id $\leftarrow$ unique identifier \smallbreak

In the hardware functions we utilise a special keyword \KwNow, which represents the real-time hardware clocks
of a node. It is assumed that all clocks run at the same speed. The clock variable is used to measure the
real-time spent by the node between calls to hardware functions. Initially, we store the current time in the
clock variable, and use the clock to compute the real-time difference between the calling of hardware
functions and add the difference to the localtime variable (e.g., localtime $\leftarrow$ (\KwNow $-$ clock)
$+$ localtime).

The unique identifier (id) of a node is meant to function as the address of a node for passing messages
between nodes and the Coordinator. The identifier of the Coordinator = $0$, and the identifier of the nodes
are in the range $\{ 1, 2, 3, \ldots, N \}$ for $N$ nodes.

\todo[inline]{for any action $a$, $a.start \leq a.end$}

%Common for all four hardware functions is that we initially update the localtime variable, and set the clock variable to \KwNow before returning from the function, such that the execution time spent communicating with the Coordinator is not included in the duration of the action.

\begin{algorithm}[ht]
    \DontPrintSemicolon
    \SetKwFunction{FTransmit}{Transmit}
    \SetKwProg{Fn}{Function}{}{}
    
    \Fn{\FTransmit{packet}}{
        localtime $\leftarrow$ (\KwNow $-$ clock) $+$ localtime\;
        duration $\leftarrow$ transmission-time(|packet|)\;
        end $\leftarrow$ localtime $+$ duration\;
        a $\leftarrow$ (transmit, id, localtime, end, packet)\;
        \KwSend a \KwTo Coordinator\;
        localtime $\leftarrow$ end\;
        clock $\leftarrow$ \KwNow\;
    }

    \caption{The Transmit Function.}
    \label{algo:hwfuncstransmit}
\end{algorithm}

The \texttt{Broadcast} (\autoref{algo:hwfuncstransmit}) function broadcasts a data packet. The packet is sent
to the Coordinator using the \gls{mpi}, and the Coordinator takes care of distributing the packet to
neighbouring nodes listening for packets. The duration of a transmission is computed based on the
\gls{baudrate} (the amount of bits the hardware can transmit per second~\cite{website:baudrate-mathworks}) as
well as the size of the packet, using \autoref{eq:transmission-time} found in \autoref{sec:hardwarephysics}.
% or our hardware, we assume a \gls{baudrate} $f_s = 34800$ Hz, 

After computing the duration, the transmit action is sent to the Coordinator, the localtime variable is set to
the end time and the clock is set to \KwNow, before the function returns. \medbreak

\begin{algorithm}[ht]
    \DontPrintSemicolon
    \KwResult{A packet or \KwNull}
    \SetKwFunction{FListen}{Listen}
    \SetKwProg{Fn}{Function}{}{}
    
    \Fn{\FListen{duration}}{
        localtime $\leftarrow$ (\KwNow $-$ clock) $+$ localtime\;
        a $\leftarrow$ (listen, id, localtime, localtime $+$ duration, \KwNull)\;
        \KwSend a \KwTo coordinator\;
        localtime $\leftarrow$ \KwAwait end \KwFrom Coordinator\; \label{algo:hwfuncslisten:awaitend}
        packet $\leftarrow$ \KwAwait packet \KwFrom Coordinator\;
        \tcp{The packet returned from Coordinator may be \KwNull}
        clock $\leftarrow$ \KwNow\;
        \KwRet packet\;
    }
    
    \caption{The \texttt{Listen} Function.}
    \label{algo:hwfuncslisten}
\end{algorithm}

The \texttt{Listen} (\autoref{algo:hwfuncslisten}) functions takes a duration as input and sends a listen
action to the Coordinator. After sending its action, the function waits for a response from the Coordinator at
\autoref{algo:hwfuncslisten:awaitend}. The \KwAwait keyword is blocking, which means that no other functions
can be called from a node while the node is listening for a packet. When the Coordinator processes a listen
action, two messages will be sent to the node. The first is the end time, which is assigned to the localtime
variable, and the second is the packet received (if any). If no packet has been received, the end time
received from the Coordinator will be the same as the end time in the action sent to the Coordinator
(localtime $+$ duration), and the packet received will be \KwNull. If a packet has been received, the
Coordinator will send the time when the packet was received, with the packet following right after.

At most a single packet may be received on a call to the \texttt{Listen} function, but depending on the number
of transmissions in the same time interval, no packet could be received, as multiple transmissions either will
provide interference for each other, creating collisions, or no transmissions may have happened in the time
interval.

After receiving a response from the Coordinator, the function will set the clock variable to \KwNow, and
return either the packet or \KwNull. \medbreak

\begin{algorithm}[ht]
    \DontPrintSemicolon
    \SetKwFunction{FSleep}{Sleep}
    \SetKwProg{Fn}{Function}{}{}
    
    \Fn{\FSleep{duration}}{
        localtime $\leftarrow$ (\KwNow $-$ clock) $+$ localtime\;
        end $\leftarrow$ localtime $+$ duration\;
        a $\leftarrow$ (sleep, id, localtime, end, \KwNull)\;
        \KwSend a \KwTo Coordinator\;
        localtime $\leftarrow$ end\;
        clock $\leftarrow$ \KwNow\;
    }
    
    \caption{The \texttt{Sleep} Function.}
    \label{algo:hwfuncssleep}
\end{algorithm}

The \texttt{Sleep} (\autoref{algo:hwfuncssleep}) takes a duration as input and sends a sleep action to the
Coordinator. As no response is expected of the Coordinator, the function sets the localtime and clock
variables immediately after sending the action. \medbreak

\begin{algorithm}[ht]
    \DontPrintSemicolon
    \SetKwFunction{FInformLocalTime}{InformLocalTime}
    \SetKwProg{Fn}{Function}{}{}
    
    \Fn{\FInformLocalTime{}}{
        localtime $\leftarrow$ (\KwNow $-$ clock) $+$ localtime\;
        a $\leftarrow$ (inform, id, localtime, localtime, \KwNull)\;
        \KwSend a \KwTo Coordinator\;
        clock $\leftarrow$ \KwNow\;
    }
    
    \caption{The \texttt{InformLocaltime} Function.}
    \label{algo:hwfuncsupdatelocaltime}
\end{algorithm}

The \texttt{InformLocalTime} function is equivalent to the \texttt{Sleep} function in the sense that it
behaves like the \texttt{Sleep} function with the duration set to 0. The function is included in the case
there none of the other hardware functions are applicable, e.g., in the case where the node is performing
longer computations,. Regularly informing the Coordinator of a nodes localtime will allow the Coordinator to
continually process actions from other nodes.